35p 덧셈연산은 같은 데이터값끼리 되기 때문에, str()을 쓴다!
(참고) input함수는 파라미터를 하나만 받는다. (print처럼 쉼표로 여러개 파라미터 넣는 것 안된다.)


39p
컴프리헨션, 이해하는 게 중요하다! 빈리스트 만들고 거기다 채우자.
최종적으로 넣고자 하는 애를 빈 리스트에 먼저 쓰고, 그다음에 순서대로 쓰면 됨
컴프리핸션은 이해하는 정도로 하면 된다. (컴프리핸션을 보고 결과과 어떻게 되는지를 물어보지,
결과를 가지고 컴프리핸션을 짜시오 라고는 시험으로 안낸다!)


컴프리핸션은 약식으로 간략하게 쓸 때 쓰는 느낌~

41p zip이라는 함수는 지퍼처럼 두개를 붙여주는 역할~
길이가 다른 애들도 붙여줄 수 있음!
다 짝을 지으면 끝나고, 오류가 나지 않음!

42p 그래서 이렇게 되는 구나 정도만 이해하기, 결과가 이렇게 되는데 왜그렇게 되는지만 눈으로 확인할 수 있는 정도가 시험에 나온다!

-

9장

3p. 열거형 데이터파일에서 전부 sorted 쓸 수 있다!
sorted 기본은 오름차순 정렬이다. 굳이 내림차순으로 정렬하고 싶으면 reverse 해주기!

10p 컴프리핸션

<오늘의 코드>

"""L = [num for num in range(1,21) if num%3 == 0]
print(L)"""

"""foods = ['떡볶이', '짜장면', '라면', '피자', '맥주', '치킨', '삼겹살']
sides = ['오뎅', '단무지', '김치']
for food, side in zip(foods, sides) :
    print(food, ' --> ', side)"""

foods = ['떡볶이', '짜장면', '라면', '피자', '맥주', '치킨', '삼겹살']
sides = ['오뎅', '단무지', '김치']
tupL = list(zip(foods, sides))
dic = dict(zip(foods, sides))
print(tupL)
print(dic)
